{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(rootSaga);\n\nimport { all, fork } from \"redux-saga/effects\"; // 디바운싱 -> 검색창에 입력할때 주로 사용\n// 쓰로틀링 -> 스크롤 할때 주로 사용 \n\nimport postSaga from \"./post\";\nimport userSaga from \"./user\";\nexport default function rootSaga() {\n  return _regeneratorRuntime.wrap(function rootSaga$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.next = 2;\n          return all([// all -> 배열을 받는다 : 배열에 받은 것들을 한번에 실행된다. (동시에)\n          // fork -> 해당 함수를 실행한다. \n          // call -> fork 또는 call로 함수를 실행 \n          // fork : 비동기 함수호출(결과 기다리지 않고 바로 다음 실행) / call: 동기 함수 호출(await , .then 처럼 결과값을 받아올때 까지 기다려줌)\n          fork(postSaga), fork(userSaga)]);\n\n        case 2:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n} // const gen = function*(){} -> 제너레이터 함수\n// gen() -> not working\n// gen().next() -> working \n// const gen = function* () { \n//     console.log(1)\n//     yield;\n//     console.log(2);\n//     yield;\n//     console.log(3);\n//     yield 4;\n// }\n// const generator = gen();\n// generator.next() -> 실행하면 console.log(1) 과 { value : unde~, done: false } 던져준다.\n// -> 즉 console.log(1), yield 까지 하고 멈춘것\n// 또 generator.next() 실행하면 console에 2 를 확인하고 { value : unde~, done: false } 던져준다.\n// 또 다시 실행시키면 콘솔에는 3과 { value: 4, done: false} 를 확인할 수 있다.\n// 한번 더 실행하게 되면 { value: undefined, done: true} 까지 확인 가능하다.\n// 즉 yield 가 있는곳에서 멈춘다는 것을 알 수 있다. \n// saga 에서 절대 멈추지 않는 제너레이터 함수\n// const gen = function*(){\n//     while(true) {\n//         yield '무한';\n//     }\n// }\n// -> 매번 중단된다 \n// const g = gen();\n// g.next() -> 무한반복 되지 않고 {value: \"무한\", done:false} 만 던져준다.\n// 제너레이터로 이벤트리스너 처럼도 사용 가능하다. \n// -----------------------------------user로 간 함수들-----------------------------------\n// // * 을 붙이지 않는다 !!\n// function logInAPI () {\n//     // 실제 서버에 요청을 보낸다. \n//     return axios.post(\"/api/login\")\n// }\n// function* login (action) {\n//     // put : dispatch 같은 역할 : 해당 객체를 dispatch 한다.\n//     // call , fork (함수자리, 첫번째 함수자리 이후부터는 인자자리, 인자자리, 인자자리, 인자...)\n//     try {\n//         // delay -> setTimeout 같은 역할\n//         // const result = yield call(logInAPI, action.data)\n//         yield delay(1000)\n//         yield put({\n//             type: \"LOG_IN_SUCCESS\",\n//             data: result.data\n//         })\n//     } catch(err) {\n//         yield put({\n//             type: \"LOG_IN_FAILURE\",\n//             data: err.response.data\n//         })\n//     }\n// }   \n// function logOutAPI () {\n//     return axios.post(\"/api/logout\")\n// }\n// function* logOut () {\n//     try {\n//         const result = yield call(logOutAPI)\n//         yield put({\n//             type: \"LOG_OUT_SUCCESS\",\n//             data: result.data\n//         })\n//     } catch(err) {\n//         yield put({\n//             type: \"LOG_OUT_FAILURE\",\n//             data: err.response.data\n//         })\n//     }\n// }   \n// function* watchLogin() {\n//     // take : 로그인이라는 액션이 실행될때 까지 기다리겠다. \n//     // yield 의 치명적 단점 -> 1회용\n//     // -> while 로 감싸면 무한하게 사용 가능 \n//     // while take -> 동기적으로 동작\n//     // take Every -> 비동기로 동작 \n//     // -> while 문 대체 가능 \n//     yield takeLatest(\"LOG_IN_REQUEST\", login);\n// }\n// // takeLatest -> 마우스 두번눌리는 인식되는 경우 앞에 실수로 눌린거는 무시되고 마지막꺼만 살려준다.\n// // 완료되지 않은 둘다 로딩중인 상태일때 해당 \n// // 치명적 단점 : 요청을 취소하는게 아니라 응답을 취소하는거라 서버쪽에 똑같은 데이터가 연달아 저장되지는 않았는지 검사 필수 ( 요청까지는 취소 X ) , trottle 을 사용해야함  \n// // ex yield throttle(\"ADD_POST_REQUEST\", addPost, 10000) -> 10초 동안은 1번만 실행 (시간제한)\n// // takeLeading -> 첫번째 이벤트만 \n// function* watchLogOut() {\n//     yield takeLatest(\"LOG_OUT_REQUEST\", logOut);\n// }\n// -----------------------------------post로 간 함수들-----------------------------------\n// function addPostAPI (data) {\n//     return axios.post(\"/api/post\", data)\n// }\n// function* addPost (action) {\n//     try {\n//         const result = yield call(addPostAPI, action.data)\n//         yield put({\n//             type: \"ADD_POST_SUCCESS\",\n//             data: result.data\n//         })\n//     } catch(err) {\n//         yield put({\n//             type: \"ADD_POST_FAILURE\",\n//             data: err.response.data\n//         })\n//     }\n// }   \n// function* watchAddPost() {\n//     yield takeLatest(\"ADD_POST_REQUEST\", addPost);\n//     // yield throttle(\"ADD_POST_REQUEST\", addPost, 10000);\n// }","map":{"version":3,"sources":["/Users/ijin-a/Desktop/github-react-nodebird/prepare/front/sagas/index.js"],"names":["rootSaga","all","fork","postSaga","userSaga"],"mappings":";;oDASyBA,Q;;AATzB,SAASC,GAAT,EAAcC,IAAd,QAA0B,oBAA1B,C,CAEA;AACA;;AAEA,OAAOC,QAAP,MAAqB,QAArB;AACA,OAAOC,QAAP,MAAqB,QAArB;AAGA,eAAe,SAAUJ,QAAV;AAAA;AAAA;AAAA;AAAA;AAAA;AACX,iBAAMC,GAAG,CAAC,CACN;AACA;AACA;AACA;AAEAC,UAAAA,IAAI,CAACC,QAAD,CANE,EAOND,IAAI,CAACE,QAAD,CAPE,CAAD,CAAT;;AADW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,C,CAYf;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA","sourcesContent":["import { all, fork } from \"redux-saga/effects\"\n\n// 디바운싱 -> 검색창에 입력할때 주로 사용\n// 쓰로틀링 -> 스크롤 할때 주로 사용 \n\nimport postSaga from \"./post\"\nimport userSaga from \"./user\"\n\n\nexport default function* rootSaga(){\n    yield all([\n        // all -> 배열을 받는다 : 배열에 받은 것들을 한번에 실행된다. (동시에)\n        // fork -> 해당 함수를 실행한다. \n        // call -> fork 또는 call로 함수를 실행 \n        // fork : 비동기 함수호출(결과 기다리지 않고 바로 다음 실행) / call: 동기 함수 호출(await , .then 처럼 결과값을 받아올때 까지 기다려줌)\n\n        fork(postSaga),\n        fork(userSaga),\n    ])\n}\n\n// const gen = function*(){} -> 제너레이터 함수\n// gen() -> not working\n// gen().next() -> working \n\n// const gen = function* () { \n//     console.log(1)\n//     yield;\n//     console.log(2);\n//     yield;\n//     console.log(3);\n//     yield 4;\n// }\n// const generator = gen();\n// generator.next() -> 실행하면 console.log(1) 과 { value : unde~, done: false } 던져준다.\n// -> 즉 console.log(1), yield 까지 하고 멈춘것\n// 또 generator.next() 실행하면 console에 2 를 확인하고 { value : unde~, done: false } 던져준다.\n// 또 다시 실행시키면 콘솔에는 3과 { value: 4, done: false} 를 확인할 수 있다.\n// 한번 더 실행하게 되면 { value: undefined, done: true} 까지 확인 가능하다.\n\n// 즉 yield 가 있는곳에서 멈춘다는 것을 알 수 있다. \n\n// saga 에서 절대 멈추지 않는 제너레이터 함수\n// const gen = function*(){\n//     while(true) {\n//         yield '무한';\n//     }\n// }\n// -> 매번 중단된다 \n// const g = gen();\n// g.next() -> 무한반복 되지 않고 {value: \"무한\", done:false} 만 던져준다.\n// 제너레이터로 이벤트리스너 처럼도 사용 가능하다. \n\n\n\n\n\n\n// -----------------------------------user로 간 함수들-----------------------------------\n\n\n// // * 을 붙이지 않는다 !!\n// function logInAPI () {\n//     // 실제 서버에 요청을 보낸다. \n//     return axios.post(\"/api/login\")\n// }\n\n// function* login (action) {\n//     // put : dispatch 같은 역할 : 해당 객체를 dispatch 한다.\n//     // call , fork (함수자리, 첫번째 함수자리 이후부터는 인자자리, 인자자리, 인자자리, 인자...)\n//     try {\n//         // delay -> setTimeout 같은 역할\n//         // const result = yield call(logInAPI, action.data)\n//         yield delay(1000)\n//         yield put({\n//             type: \"LOG_IN_SUCCESS\",\n//             data: result.data\n//         })\n//     } catch(err) {\n//         yield put({\n//             type: \"LOG_IN_FAILURE\",\n//             data: err.response.data\n//         })\n//     }\n    \n// }   \n// function logOutAPI () {\n//     return axios.post(\"/api/logout\")\n// }\n\n// function* logOut () {\n//     try {\n//         const result = yield call(logOutAPI)\n//         yield put({\n//             type: \"LOG_OUT_SUCCESS\",\n//             data: result.data\n//         })\n//     } catch(err) {\n//         yield put({\n//             type: \"LOG_OUT_FAILURE\",\n//             data: err.response.data\n//         })\n//     }\n    \n// }   \n\n// function* watchLogin() {\n//     // take : 로그인이라는 액션이 실행될때 까지 기다리겠다. \n//     // yield 의 치명적 단점 -> 1회용\n//     // -> while 로 감싸면 무한하게 사용 가능 \n//     // while take -> 동기적으로 동작\n//     // take Every -> 비동기로 동작 \n//     // -> while 문 대체 가능 \n\n//     yield takeLatest(\"LOG_IN_REQUEST\", login);\n    \n// }\n\n// // takeLatest -> 마우스 두번눌리는 인식되는 경우 앞에 실수로 눌린거는 무시되고 마지막꺼만 살려준다.\n// // 완료되지 않은 둘다 로딩중인 상태일때 해당 \n// // 치명적 단점 : 요청을 취소하는게 아니라 응답을 취소하는거라 서버쪽에 똑같은 데이터가 연달아 저장되지는 않았는지 검사 필수 ( 요청까지는 취소 X ) , trottle 을 사용해야함  \n// // ex yield throttle(\"ADD_POST_REQUEST\", addPost, 10000) -> 10초 동안은 1번만 실행 (시간제한)\n// // takeLeading -> 첫번째 이벤트만 \n// function* watchLogOut() {\n//     yield takeLatest(\"LOG_OUT_REQUEST\", logOut);\n// }\n\n\n\n// -----------------------------------post로 간 함수들-----------------------------------\n\n// function addPostAPI (data) {\n//     return axios.post(\"/api/post\", data)\n// }\n\n// function* addPost (action) {\n//     try {\n//         const result = yield call(addPostAPI, action.data)\n//         yield put({\n//             type: \"ADD_POST_SUCCESS\",\n//             data: result.data\n//         })\n//     } catch(err) {\n//         yield put({\n//             type: \"ADD_POST_FAILURE\",\n//             data: err.response.data\n//         })\n//     }\n    \n// }   \n\n\n// function* watchAddPost() {\n//     yield takeLatest(\"ADD_POST_REQUEST\", addPost);\n//     // yield throttle(\"ADD_POST_REQUEST\", addPost, 10000);\n// }\n"]},"metadata":{},"sourceType":"module"}